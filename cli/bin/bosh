#!/usr/bin/env ruby

require "rubygems"
require "bundler/setup"
require "optparse"
require "main"
require "highline/import"

$:.unshift(File.expand_path("../../lib", __FILE__))
require "cli"

GLOBAL_OPTIONS = {}

def run_cmd(*args)
  command = args.shift
  output  = $stdout
 
  Bosh::Cli::Runner.run(command, output, GLOBAL_OPTIONS, *args)

rescue Bosh::Cli::CliError => e
  output.puts("ERROR: #{e}")
ensure
  output.write("\n");
  output.flush
end

def display_usage
  puts <<-USAGE

usage: #$0 [--verbose|-v] [--config|-c <FILE>] command [<args>]

Currently available bosh commands are:

  target <name>                            Choose target to work with

  deployment <name>                        Choose deployment to work with (it also updates current target)

  user create <username> [<password>]      Create user

  login <username> [<password>]            Use given username for the subsequent interactions

  release upload /path/to/release.tgz      Upload the release
  release verify /path/to/release.tgz      Verify the release

  stemcell upload /path/to/stemcell.tgz    Upload the stemcell
  stemcell verify /path/to/stemcell.tgz    Verify the stemcell

  status                                   Show current status (current target, user, deployment info etc.)

  deploy                                   Deploy according to the currently selected deployment

USAGE
end

opt_parser = OptionParser.new do |opts|
  opts.on("-c", "--config FILE") do |v|
    GLOBAL_OPTIONS[:config] = v
  end
  
  opts.on("-v", "--[no-]verbose") do |v|
    GLOBAL_OPTIONS[:verbose] = v
  end

  opts.on("--dry-run") do |v|
    GLOBAL_OPTIONS[:dry_run] = v
  end

  opts.on("-u", "--username USER", String) do |v|
    GLOBAL_OPTIONS[:username] = v
  end

  opts.on("-u", "--password PASSWORD", String) do |v|
    GLOBAL_OPTIONS[:password] = v
  end  
end

opt_parser.parse!(ARGV)

# ARGV now contains options not parsed by OptionParser, and that's exactly
# what we need for handling different modes with main gem.
Main {

  def self.mode_aliases(*mode_names, &block)
    for mode_name in mode_names
      mode(mode_name) { yield }
    end
  end

  def run
    display_usage
  end

  mode_aliases("help", "-h", "--help") do
    display_usage
  end

  mode "version" do
    def run
      puts "Bosh %s" % [ Bosh::Cli::VERSION ]
    end
  end

  mode "target" do
    argument :name do
      optional
    end

    def run
      if params['name'].given?
        run_cmd(:set_target, params['name'].value)
      else
        run_cmd(:show_target)
      end
    end
  end

  # 'deploy' mode needs to be above 'deployment',
  # otherwise main considers it unambigious (bug?)
  mode "deploy" do
    def run
      run_cmd(:deploy)
    end
  end

  mode "deployment" do
    argument :name do
      optional
    end

    def run
      if params['name'].given?
        run_cmd(:set_deployment, params['name'].value)
      else
        run_cmd(:show_deployment)
      end
    end    
  end

  mode "status" do
    def run
      run_cmd(:status)
    end
  end

  mode "login" do
    usage = "usage: #$0 login <username> [<password>]"

    argument :username do
      error { puts "missing username\n#{usage}\n\n" }
    end

    argument :password do
      optional
    end

    def run
      username  = params["username"].value

      password = \
      if params["password"].given?
        params["password"].value
      else
        ask("Enter password: ") { |q| q.echo = "*" }
      end

      run_cmd(:login, username, password)
    end    
  end

  mode "user" do
    usage = "usage: #$0 user create <username> [<password>]"
    
    argument :operation do
      validate { |op| [ "create" ].include?(op) }
      error { puts "#{usage}\n\n" }
    end

    argument :username do
      error { puts "missing username\n#{usage}\n\n" }
    end

    argument :password do
      optional
    end

    def run
      operation = params["operation"].value
      username  = params["username"].value

      password = \
      if params["password"].given?
        params["password"].value
      else
        ask("Enter password: ") { |q| q.echo = "*" }
      end

      case operation
        when "create": run_cmd(:create_user, username, password)
      end
    end
  end

  mode "stemcell" do
    usage = "usage: #$0 stemcell (upload|verify) /path/to/stemcell.tgz"
    
    argument :operation do
      validate { |op| [ "verify", "upload" ].include?(op) }
      error { puts "#{usage}\n\n" }
    end

    argument :stemcell_bundle do
      error { puts "missing stemcell filename\n#{usage}\n\n" }
    end

    def run
      operation    = params["operation"].value
      tarball_path = params["stemcell_bundle"].value

      case operation
      when "verify": run_cmd(:verify_stemcell, tarball_path)
      when "upload": run_cmd(:upload_stemcell, tarball_path)
      end
    end    
  end

  mode "release" do
    usage = "usage: #$0 release (upload|verify) /path/to/release.tgz"
    
    argument :operation do
      validate { |op| [ "verify", "upload" ].include?(op) }
      error { puts "#{usage}\n\n" }
    end

    argument :release_bundle do
      error { puts "missing release filename\n#{usage}\n\n" }
    end

    def run
      operation    = params["operation"].value
      tarball_path = params["release_bundle"].value

      case operation
      when "verify": run_cmd(:verify_release, tarball_path)
      when "upload": run_cmd(:upload_release, tarball_path)
      end
    end    
  end
}
