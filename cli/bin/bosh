#!/usr/bin/env ruby

gemfile = File.expand_path("../../Gemfile", __FILE__)

if File.exists?(gemfile)
  ENV["BUNDLE_GEMFILE"] = gemfile
  require "rubygems"
  require "bundler/setup"
end

require "optparse"
require "main"
require "highline/import"

$:.unshift(File.expand_path("../../lib", __FILE__))
require "cli"

GLOBAL_OPTIONS = {
  :director_checks => true
}

trap("INT") { puts "Exiting..."; exit(0) }

def run_cmd(*args)
  command = args.shift
  Bosh::Cli::Config.output = $stdout
  Bosh::Cli::Runner.run(command, GLOBAL_OPTIONS, *args)
ensure
  Bosh::Cli::Config.output.write("\n")
  Bosh::Cli::Config.output.flush
end

def display_usage
  puts <<-USAGE

usage: bosh [--verbose|-v] [--config|-c <FILE>] command [<args>]

Currently available bosh commands are:

  target <name>                            Choose target to work with

  deployment <name>                        Choose deployment to work with (it also updates current target)

  user create [<username>] [<password>]    Create user

  login [<username>] [<password>]          Use given username for the subsequent interactions
  logout                                   Forgets currently saved credentials

  purge                                    Purge cached data

  task <id>                                Show task status (monitor if not done)

  release upload /path/to/release.tgz      Upload the release
  release verify /path/to/release.tgz      Verify the release

  stemcell upload /path/to/stemcell.tgz    Upload the stemcell
  stemcell verify /path/to/stemcell.tgz    Verify the stemcell

  status                                   Show current status (current target, user, deployment info etc.)

  deploy                                   Deploy according to the currently selected deployment

USAGE
end

opt_parser = OptionParser.new do |opts|
  opts.on("-c", "--config FILE") do |v|
    GLOBAL_OPTIONS[:config] = v
  end

  opts.on("--cache-dir DIR") do |v|
    GLOBAL_OPTIONS[:cache_dir] = v
  end

  opts.on("-v", "--[no-]verbose") do |v|
    GLOBAL_OPTIONS[:verbose] = v
  end

  opts.on("--skip-director-checks", String) do |v|
    GLOBAL_OPTIONS[:director_checks] = false
  end    
end

opt_parser.parse!(ARGV)

# ARGV now contains options not parsed by OptionParser, and that's exactly
# what we need for handling different modes with main gem.
Main {

  def self.mode_aliases(*mode_names, &block)
    for mode_name in mode_names
      mode(mode_name) { yield }
    end
  end

  def run
    display_usage
  end

  mode "help" do
    def run
      display_usage
    end
  end

  mode "version" do
    def run
      puts "Bosh %s" % [ Bosh::Cli::VERSION ]
    end
  end

  mode "target" do
    argument :name do
      optional
    end

    def run
      if params['name'].given?
        run_cmd(:set_target, params['name'].value)
      else
        run_cmd(:show_target)
      end
    end
  end

  # 'deploy' mode needs to be above 'deployment',
  # otherwise main considers it unambigious (bug?)
  mode "deploy" do
    def run
      run_cmd(:deploy)
    end
  end

  mode "deployment" do
    argument :name do
      optional
    end

    def run
      if params['name'].given?
        run_cmd(:set_deployment, params['name'].value)
      else
        run_cmd(:show_deployment)
      end
    end    
  end

  mode "status" do
    def run
      run_cmd(:status)
    end
  end

  mode "login" do
    usage = "usage: #$0 login [<username>] [<password>]"

    argument :username do
      optional
    end

    argument :password do
      optional
    end

    def run
      username = \
      if params["username"].given?
        params["username"].value
      else
        ask("You username: ")
      end

      password = \
      if params["password"].given?
        params["password"].value
      else
        ask("Enter password: ") { |q| q.echo = "*" }
      end

      logged_in = run_cmd(:login, username, password)

      if logged_in == :retry && !params["password"].given?
        exec "#$0 login #{username}"
      end
      
    end    
  end

  mode "logout" do
    def run
      run_cmd(:logout)
    end
  end

  mode "purge" do
    def run
      run_cmd(:purge)
    end
  end
  
  mode "user" do
    usage = "usage: #$0 user create [<username>] [<password>]"
    
    argument :operation do
      validate { |op| [ "create" ].include?(op) }
      error { puts "#{usage}\n\n" }
    end

    argument :username do
      optional
    end

    argument :password do
      optional
    end

    def run
      operation = params["operation"].value
      username  = \
      if params["username"].given?
        params["username"].value
      else
        ask("Enter username: ")
      end

      password = \
      if params["password"].given?
        params["password"].value
      else
        ask("Enter password: ") { |q| q.echo = "*" }
      end

      case operation
        when "create": run_cmd(:create_user, username, password)
      end
    end
  end

  mode "stemcell" do
    usage = "usage: #$0 stemcell (upload|verify) /path/to/stemcell.tgz"
    
    argument :operation do
      validate { |op| [ "verify", "upload" ].include?(op) }
      error { puts "#{usage}\n\n" }
    end

    argument :stemcell_bundle do
      error { puts "missing stemcell filename\n#{usage}\n\n" }
    end

    def run
      operation    = params["operation"].value
      tarball_path = params["stemcell_bundle"].value

      case operation
      when "verify": run_cmd(:verify_stemcell, tarball_path)
      when "upload": run_cmd(:upload_stemcell, tarball_path)
      end
    end    
  end

  mode "task" do
    argument :task_id

    def run
      run_cmd(:show_task, params["task_id"].value)
    end
  end

  mode "release" do
    usage = "usage: #$0 release (upload|verify) /path/to/release.tgz"
    
    argument :operation do
      validate { |op| [ "verify", "upload" ].include?(op) }
      error { puts "#{usage}\n\n" }
    end

    argument :release_bundle do
      error { puts "missing release filename\n#{usage}\n\n" }
    end

    def run
      operation    = params["operation"].value
      tarball_path = params["release_bundle"].value

      case operation
      when "verify": run_cmd(:verify_release, tarball_path)
      when "upload": run_cmd(:upload_release, tarball_path)
      end
    end    
  end
}
